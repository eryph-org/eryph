using System.Linq.Expressions;
using Dbosoft.Functional.Validations;
using Eryph.ConfigModel;
using Eryph.ConfigModel.Catlets;
using LanguageExt;
using LanguageExt.Common;

using static Dbosoft.Functional.Validations.ComplexValidations;
using static LanguageExt.Prelude;

namespace Eryph.CatletManagement;

public static class CatletUpdateValidator
{
    /// <summary>
    /// Validates the given <paramref name="updateConfig"/> and ensures that it
    /// does not contain invalid changes.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The <paramref name="currentConfig"/> should be generated by
    /// <see cref="CatletConfigGenerator"/>.
    /// </para>
    /// <para>
    /// The validation is rather restrictive and prevents operations which would
    /// completely break the catlet (e.g. removing the boot disk).
    /// </para>
    /// </remarks>
    public static Validation<ValidationIssue, Unit> Validate(
        CatletConfig updateConfig,
        CatletConfig currentConfig,
        string path = "") =>
        ValidateProperty(updateConfig, c => c.ConfigType, ValidateConfigType, path, required: true)
        | ValidatePropertyValue<CatletConfig, ProjectName>(updateConfig, c => c.Project, currentConfig.Project, path)
        | ValidatePropertyValue<CatletConfig, EnvironmentName>(updateConfig, c => c.Environment, currentConfig.Environment, path)
        | ValidatePropertyValue<CatletConfig, DataStoreName>(updateConfig, c => c.Store, currentConfig.Store, path)
        | ValidatePropertyValue<CatletConfig, StorageIdentifier>(updateConfig, c => c.Location, currentConfig.Location, path)
        | ValidatePropertyValue<CatletConfig, GeneSetIdentifier>(updateConfig, c => c.Parent, currentConfig.Parent, path)
        | ValidateProperty(updateConfig, c => c.Hostname, v => ValidateHostname(v, currentConfig.Hostname), path, required: true)
        | ValidateDrives(updateConfig, currentConfig, path)
        | ValidateProperty(updateConfig, c => c.Fodder,
            _ => Fail<Error, Unit>(Error.New("Fodder is not supported when updating an existing catlet.")),
            path)
        | ValidateProperty(updateConfig, c => c.Variables,
            _ => Fail<Error, Unit>(Error.New("Variables are not supported when updating an existing catlet.")),
            path);

    private static Validation<Error, Unit> ValidateConfigType(CatletConfigType configType) =>
        guard(configType is CatletConfigType.Instance,
                Error.New("The configuration must be an instance configuration."))
            .ToValidation();

    private static Validation<ValidationIssue, Unit> ValidateDrives(
        CatletConfig updateConfig,
        CatletConfig originalConfig,
        string path = "") =>
        from _1 in Success<ValidationIssue, Unit>(unit)
        from originalGeneDrives in originalConfig.Drives.ToSeq()
            .Filter(d => Optional(d.Source).Map(s => s.StartsWith("gene:")).IfNone(false))
            .Map(d => from n in CatletDriveName.NewValidation(d.Name)
                      select (n, d))
            .Sequence()
            .Map(s => s.ToHashMap())
            .MapFail(e => new ValidationIssue(path, $"BUG! The original config contains an invalid drive name: {e.Message}."))
        from _2 in ValidateList(updateConfig, c => c.Drives,
            (d,p) => ValidateDrive(d, originalGeneDrives, p),
            path)
        from _3 in ValidateNoMissingDrives(
            updateConfig.Drives.ToSeq(),
            toHashSet(originalGeneDrives.Keys),
            JoinPath(path, nameof(CatletConfig.Drives)))
        select unit;

    private static Validation<ValidationIssue, Unit> ValidateDrive(
        CatletDriveConfig updateConfig,
        HashMap<CatletDriveName, CatletDriveConfig> originalGeneDrives,
        string path = "") =>
        from _1 in ValidateProperty(updateConfig, d => d.Name, CatletDriveName.NewValidation, path, required: true)
        let name = CatletDriveName.New(updateConfig.Name)
        from _2 in originalGeneDrives.Find(name).Match(
            Some: originalConfig => ValidateDrive(updateConfig, originalConfig, path),
            None: () => ValidateDrive(updateConfig, path))
        select unit;

    private static Validation<ValidationIssue, Unit> ValidateDrive(
        CatletDriveConfig updateConfig,
        CatletDriveConfig originalConfig,
        string path = "") =>
        ValidateProperty<CatletDriveConfig, CatletDriveType, Unit>(
            updateConfig,
            d => d.Type,
            t => guard(
                    t == CatletDriveType.Vhd,
                    Error.New(
                        "The drive type of a gene pool drive cannot be changed when updating an existing catlet."))
                .ToValidation(),
            path)
        | ValidatePropertyValue<CatletDriveConfig, DataStoreName>(updateConfig, d => d.Store, originalConfig.Store, path)
        | ValidatePropertyValue<CatletDriveConfig, StorageIdentifier>(updateConfig, d => d.Location, originalConfig.Location, path)
        | ValidatePropertyValue<CatletDriveConfig, GeneIdentifier>(updateConfig, d => d.Source, originalConfig.Source, path);

    private static Validation<ValidationIssue, Unit> ValidateDrive(
        CatletDriveConfig updateConfig,
        string path = "") =>
        ValidateProperty(
            updateConfig,
            d => d.Source,
            s => guardnot(
                    s.StartsWith("gene:", StringComparison.OrdinalIgnoreCase),
                    Error.New("Cannot add new gene pool drives when updating an existing catlet."))
                .ToValidation(),
            path);

    private static Validation<ValidationIssue, Unit> ValidateNoMissingDrives(
        Seq<CatletDriveConfig> updateDrives,
        LanguageExt.HashSet<CatletDriveName> originalGeneDrives,
        string path = "") =>
        from updateDriveNames in updateDrives
            .Map(d => CatletDriveName.NewValidation(d.Name))
            .Sequence()
            .MapFail(e => new ValidationIssue(path, e.Message))
            .Map(s => s.ToHashSet())
        from _ in originalGeneDrives.Except(updateDriveNames)
            .Map(n => Fail<ValidationIssue, Unit>(new ValidationIssue(
                path, $"The drive {n} cannot be removed when updating the catlet.")))
            .Sequence()
        select unit;

    private static Validation<ValidationIssue, Unit> ValidatePropertyValue<T, TValue>(
        T toValidate,
        Expression<Func<T, string?>> getProperty,
        string? expectedValue,
        string path = "")
        where TValue : EryphName<TValue> =>
        Optional(expectedValue).Filter(notEmpty).Match(
            Some: ev => ValidateProperty(toValidate, getProperty,
                v => ValidateValue<TValue>(v, ev), path, required: true),
            None: () => ValidateProperty(toValidate, getProperty,
                _ => Fail<Error, Unit>(Error.New("The value cannot be changed when updating an existing catlet.")), path));
    
    private static Validation<Error, string> ValidateValue<TValue>(
        string actualValue,
        string expectedValue)
        where TValue : EryphName<TValue> =>
        from validExpectedValue in EryphName<TValue>.NewValidation(expectedValue)
            // Nested errors cannot be used here as we convert to ValidationIssue laters
            .MapFail(e => Error.New($"BUG! The expected value '{expectedValue}' is invalid: {e.Message}"))
        from validActualValue in EryphName<TValue>.NewValidation(actualValue)
        from _ in guard(validActualValue == validExpectedValue,
                Error.New("The value cannot be changed when updating an existing catlet."))
            .ToValidation()
        select actualValue;

    private static Validation<Error, string?> ValidateHostname(
        string? actualValue,
        string? expectedValue) =>
        from _ in guard(actualValue == expectedValue,
                Error.New("The hostname cannot be changed when updating an existing catlet."))
            .ToValidation()
        select actualValue;

    private static string JoinPath(string path, string propertyName) =>
        notEmpty(path) ? $"{path}.{propertyName}" : propertyName;
}
